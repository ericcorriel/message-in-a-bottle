(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{382:function(n,e,t){"use strict";t.r(e);var o=t(57),component=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("client-only",[t("div",{attrs:{id:"overlay"}},[t("button",{attrs:{id:"startButton"}},[n._v("Play")])]),n._v(" "),t("div",{attrs:{id:"container"}}),n._v(" "),t("div",{attrs:{id:"info"}},[t("a",{attrs:{href:"https://threejs.org",target:"_blank",rel:"noopener"}},[n._v("three.js")]),n._v("\n      - webgl video demo"),t("br"),n._v("\n      playing\n      "),t("a",{attrs:{href:"http://durian.blender.org/",target:"_blank",rel:"noopener"}},[n._v("sintel")]),n._v("\n      trailer\n    ")]),n._v(" "),t("video",{staticStyle:{display:"none"},attrs:{id:"video",loop:"",crossOrigin:"anonymous",playsinline:""}},[t("source",{attrs:{src:"/IMG_6826-450-years-landscape.mp4",type:'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'}})]),n._v(" "),t("script",{attrs:{type:"module"}},[n._v('\n      import * as THREE from "/js/three.module.js";\n      import { EffectComposer } from "/js/jsm/postprocessing/EffectComposer.js";\n      import { RenderPass } from "/js/jsm/postprocessing/RenderPass.js";\n      import { ShaderPass } from "/js/jsm/postprocessing/ShaderPass.js";\n      import { BloomPass } from "/js/jsm/postprocessing/BloomPass.js";\n      import { CopyShader } from "/js/jsm/shaders/CopyShader.js";\n\n      let container;\n\n      let camera, scene, renderer;\n\n      let video, texture, material, mesh;\n\n      let composer;\n\n      let mouseX = 0;\n      let mouseY = 0;\n\n      let windowHalfX = window.innerWidth / 2;\n      let windowHalfY = window.innerHeight / 2;\n\n      let cube_count;\n\n      const meshes = [],\n        materials = [],\n        xgrid = 20,\n        ygrid = 10;\n\n      const startButton = document.getElementById("startButton");\n      startButton.addEventListener("click", function () {\n        init();\n        animate();\n      });\n\n      function init() {\n        const overlay = document.getElementById("overlay");\n        overlay.remove();\n\n        container = document.createElement("div");\n        document.body.appendChild(container);\n\n        camera = new THREE.PerspectiveCamera(\n          40,\n          window.innerWidth / window.innerHeight,\n          1,\n          10000\n        );\n        camera.position.z = 500;\n\n        scene = new THREE.Scene();\n\n        const light = new THREE.DirectionalLight(0xffffff);\n        light.position.set(0.5, 1, 1).normalize();\n        scene.add(light);\n\n        renderer = new THREE.WebGLRenderer();\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        container.appendChild(renderer.domElement);\n\n        video = document.getElementById("video");\n        video.play();\n        video.addEventListener("play", function () {\n          this.currentTime = 3;\n        });\n\n        texture = new THREE.VideoTexture(video);\n\n        //\n\n        let i, j, ox, oy, geometry;\n\n        const ux = 1 / xgrid;\n        const uy = 1 / ygrid;\n\n        const xsize = 480 / xgrid;\n        const ysize = 204 / ygrid;\n\n        const parameters = { color: 0xffffff, map: texture };\n\n        cube_count = 0;\n\n        for (i = 0; i < xgrid; i++) {\n          for (j = 0; j < ygrid; j++) {\n            ox = i;\n            oy = j;\n\n            geometry = new THREE.BoxGeometry(xsize, ysize, xsize);\n\n            change_uvs(geometry, ux, uy, ox, oy);\n\n            materials[cube_count] = new THREE.MeshLambertMaterial(parameters);\n\n            material = materials[cube_count];\n\n            material.hue = i / xgrid;\n            material.saturation = 1 - j / ygrid;\n\n            material.color.setHSL(material.hue, material.saturation, 0.5);\n\n            mesh = new THREE.Mesh(geometry, material);\n\n            mesh.position.x = (i - xgrid / 2) * xsize;\n            mesh.position.y = (j - ygrid / 2) * ysize;\n            mesh.position.z = 0;\n\n            mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;\n\n            scene.add(mesh);\n\n            mesh.dx = 0.001 * (0.5 - Math.random());\n            mesh.dy = 0.001 * (0.5 - Math.random());\n\n            meshes[cube_count] = mesh;\n\n            cube_count += 1;\n          }\n        }\n\n        renderer.autoClear = false;\n\n        document.addEventListener("mousemove", onDocumentMouseMove);\n\n        // postprocessing\n\n        const renderModel = new RenderPass(scene, camera);\n        const effectBloom = new BloomPass(1.3);\n        const effectCopy = new ShaderPass(CopyShader);\n\n        composer = new EffectComposer(renderer);\n\n        composer.addPass(renderModel);\n        composer.addPass(effectBloom);\n        composer.addPass(effectCopy);\n\n        //\n\n        window.addEventListener("resize", onWindowResize);\n      }\n\n      function onWindowResize() {\n        windowHalfX = window.innerWidth / 2;\n        windowHalfY = window.innerHeight / 2;\n\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        composer.setSize(window.innerWidth, window.innerHeight);\n      }\n\n      function change_uvs(geometry, unitx, unity, offsetx, offsety) {\n        const uvs = geometry.attributes.uv.array;\n\n        for (let i = 0; i < uvs.length; i += 2) {\n          uvs[i] = (uvs[i] + offsetx) * unitx;\n          uvs[i + 1] = (uvs[i + 1] + offsety) * unity;\n        }\n      }\n\n      function onDocumentMouseMove(event) {\n        mouseX = event.clientX - windowHalfX;\n        mouseY = (event.clientY - windowHalfY) * 0.3;\n      }\n\n      //\n\n      function animate() {\n        requestAnimationFrame(animate);\n\n        render();\n      }\n\n      let h,\n        counter = 1;\n\n      function render() {\n        const time = Date.now() * 0.00005;\n\n        camera.position.x += (mouseX - camera.position.x) * 0.05;\n        camera.position.y += (-mouseY - camera.position.y) * 0.05;\n\n        camera.lookAt(scene.position);\n\n        for (let i = 0; i < cube_count; i++) {\n          material = materials[i];\n\n          h = ((360 * (material.hue + time)) % 360) / 360;\n          material.color.setHSL(h, material.saturation, 0.5);\n        }\n\n        if (counter % 1000 > 200) {\n          for (let i = 0; i < cube_count; i++) {\n            mesh = meshes[i];\n\n            mesh.rotation.x += 10 * mesh.dx;\n            mesh.rotation.y += 10 * mesh.dy;\n\n            mesh.position.x -= 150 * mesh.dx;\n            mesh.position.y += 150 * mesh.dy;\n            mesh.position.z += 300 * mesh.dx;\n          }\n        }\n\n        if (counter % 1000 === 0) {\n          for (let i = 0; i < cube_count; i++) {\n            mesh = meshes[i];\n\n            mesh.dx *= -1;\n            mesh.dy *= -1;\n          }\n        }\n\n        counter++;\n\n        renderer.clear();\n        composer.render();\n      }\n    ')])])],1)}),[],!1,null,null,null);e.default=component.exports}}]);